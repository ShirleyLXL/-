# 操作系统笔记
## 第一章. 引言
### 1.OS
- OS是资源管理器（CPU, 存储器，外部设备，数据和软件等）
- 是扩展机（在裸机上添加设备管理，文件管理，存储管理（针对内存和外存），处理器管理（针对CPU））
- 是用户使用系统的接口（系统命令（命令行，菜单式，命令脚本式，图形用户接口GUI），系统调用）

### 2.操作系统发展历史
- 需求：器件的发展（CPU，内存容量和速度），提高资源的利用率和系统性能(多道程序，分时系统，线程，虚拟化技术)，方便用户（文本终端，图形界面，网络服务）
- 晶体管时代（批处理作业，脱机批处理操作）

### 3. 操作系统基本概念
- 系统调用（与文件有关：mount文件系统），进程（IPC）
- 文件： 文件的存放通过++目录++完成
- 命令解释器shell：本身不是操作系统的一部分
- 操作系统的特征：并发，共享，虚拟，异步性
- **并发**：多个事件在同一时间段发生。并行指的是同一时刻，程序的静态实体是可执行文件，而动态的实体是进程（或称为任务），并发指的是进程。
- **共享**：多个进程共享有限的计算机系统资源，资源在一个时间段内交替被多个进程使用。（互斥共享（音频设备），同时访问（可重入代码，磁盘文件））
- **虚拟**：一个物理实体映射为若干的对应的逻辑实体：++分时或分空间++。虚拟是操作系统管理系统资源的重要手段，可提高资源利用率。
- **异步性**：指进程的执行顺序和执行时间的不确定性

### 4. 系统调用
- 服务类型：1. 程序执行和终止，分配和回收资源；2.I/O操作；3.文件系统操作；4.通信；5.配置管理：硬件，OS本身，其他软件；6.差错检测
- 系统调用分类：
    - 1.进程管理：fork, waitpid, getpid..
    - 2.信号管理：kill, alarm, pause, sigaction
    - 3.文件管理：creat, open, close, read, write
    - 4.目录管理：mkdir, mount, link, umount
    - 5.安全管理：chmod, chwon, umask, getuid
    - 6.时间管理：time, stime, utime, times
-  MINIX中进程的内存空间：代码段，数据段，栈段
-  信号管理系统调用：信号是软件中断，定义针对信号的处理操作，sigaction(sig,&act,&oldact)是POSIX的信号接口，而signal是标准C的信号接口，kill(pid, sig)发送信号给目的进程
-  文件系统系统调用：unix     
    - shell使用文件描述符0与进程的标准输入结合，1和标准输出结合，2与标准出错输出结合
    - 一个进程有两个不同的打开文件，一个为标准输入（0），一个为标准输出（1）
    - dup()  fd = dup(1) 复制文件描述符（dup复制的新文件描述符一定是当前可用文件描述符中的最小数值）
     ```C
     fd = dup(1);
     close(1);  //关闭文件描述符1
     open(文件A);   //文件描述符为1，变为标准输出
     close(1);  //关闭文件描述符1
     n = dup(fd);   //复制文件描述符，恢复标准输出（n=1）,即有两个文件描述符1和fd指向该文件
     close(fd); //fd不用
    ```
    - 管道
    ```C
    int fd[2];
    pipe(&fd[0]);
    if(fork()!=0){
        close(fd[0]);   //进程1不需要从管道读
        close(STD_OUTPUT);
        dup(fd[1]); //dup一定分配最小的文件描述符，STD_OUTPUT，此时STD_OUTPUT和fd[1]都指向该文件
        close(fd[1]);
        execl(process1, process1, 0);
    }
    else{
        close(fd[1]);   //进程2不需要从管道读
        close(STD_INPUT);
        dup(fd[0]);
        close(fd[0]);
        execl(process2, process2, 0);
    }
    
    ```
    ```C
    int fd[2];
    
    ```
- 目录管理系统调用
    - LINK系统调用---同一个文件按不同路径名出现
    - 应用：开发小组的几个成员共享一个文件，该文件才出现在每个人自己的目录下 link("usr/jim/memo", "/usr/ast/note");
    - 每个文件都有一个唯一的数字i-node号
    - i节点中存放有文件所有者以及该文件所占用的磁盘块等信息
    - 挂装（Mount）文件系统
    - mount系统调用 mount("/dec/cdrom0","/mnt",0); 在插入存有数据的光盘后使用mount系统调用可以将光盘上的文件系统安装到根文件系统下
- 安全管理系统调用
    - 访问控制 11bit的保护方式码，9位标识权限：rwx rwx rwx （文件所有者，同组用户，其他用户）,另两位是设置组标识位和用户标识位
    - chmod系统调用可以改变文件的保护方式：chmod("file", 0644);
    - 系统命令passwd---设置用户标识位
- 时间管理系统调用
    - time：返回1970年1月1日0时距当前的时间，以秒为单位
    - stime：设置系统时间（仅超级用户）
    - utime：允许文件所有者修改存在i-node中的时间 touch命令用utime将文件时间设为当前时间
    - times：返回进程的计账信息？

### 5.操作系统组织架构
- 整体结构 最常用的组织方式。整个操作系统是一堆过程的集合，每个过程都可以调用任意其他过程。
    - 系统的每个过程都有一个定义完好的接口，互相间调用不受约束。
    - CPU有两种状态：核心/内核态和用户态(kernel mode user mode)，用户态不能执行I/O和其他的一些操作。
    - 提供系统调用，先将参数放入预先确定的寄存器或堆栈中，然后执行一条特殊的陷入指令（trap 异常处理程序）进入内核态，即supervisor call（访管程序调用）指令或内核调用指令。
    - 示例，read函数。用户调用read，将此次函数调用的参数压入栈中（C和C++参数入栈顺序相反，调用完后会将栈顶内容清除，也是普通函数调用在收尾时做的事），进入read库函数（1.一般用汇编写 2.将本次系统调用编号放在某个地方如某个寄存器）；执行一条TRAP指令，跳转到内核某个固定位置开始执行；这段内核代码检查，将其分配到相应的系统调用处理程序（查询系统调用表）；处理完后可能被阻塞（例如等待键盘输入，阻塞完后才执行下面）或回到用户空间的read库函数跳到TRAP指令的下一条指令，再返回用户程序。
    - 基本结构：1.一个主程序，用来调用被请求的服务进程。 2. 一组服务进程，用来实现相应的系统调用。3。一组工具函数，用来帮助服务例程的实现。
- 分层结构（如MINIX）
    资源管理角度：划分层次，在某一层次上代码只能调用低层次的代码。
- 虚拟机
    全虚拟化技术，半虚拟化技术，基于容器的虚拟化技术。
    - 全虚拟化技术
        用一个虚拟机管理软件处在操作系统和硬件之间。从而虚拟和管理所有的硬件资源。大型机虚拟成多个大型机，并且和硬件接口完全一致。
    - 部分虚拟化技术
        在硬件支持不完全的情况下仍能提供虚拟化。---修改客户操作系统，操作系统知道虚拟机的存在，应用程序不需要修改。
    - 基于容器的虚拟化技术
        不虚拟任何硬件设备。
        在系统上加装虚拟化平台，将系统划分为多个独立的容器，每个容器是一个虚拟的操作系统。
        计算系统上运行着唯一的操作系统实例（？）
    - 外核：负责虚拟机分配资源的使用不会发生冲突，每个虚拟机运行自己的os
    - 客户/服务器模型或微内核结构
        内核只实现操作系统的基本功能，更多操作系统功能放在核心之外，作为独立的服务进程运行（服务器进程，客户进程）。
        - LPC(local Procedure Call，本地过程调用)，一种进程之间请求-应答式的消息（Message）传递机制.
        - 消息是一定格式的数据结构①发起调用，送出请求信息②请求消息到达并进行处理③送出回答消息④整理回答消息，返回结果
        - 云计算基础：（轻量级）虚拟化技术
            - 云计算平台
            - 容器技术（如何高效管理容器）
            - Unikernel（适用于特定类型的，如Web,DB）
## 第二章 进程
### 进程
- 进程模型
    程序计数器，寄存器和变量的当前值
    代码段，数据段，栈段
    每个进程拥有自己的逻辑程序计数器（控制流），单CPU系统只有一个物理程序计数器。当进程被载入运行时，将该进程的逻辑计数器装入到物理程序计数器中。当进程终止当前运行时，将物理程序计数器中值保存在该进程的逻辑计数器中。
    - 上下文切换
    - 模式切换
    - 进程控制块PCB(即进程状态信息)
- 进程创建和终止
    - 四个原因：系统初始化；一个正在运行的进程执行了创建进程的系统调用。用户请求创建一个新进程。批处理作业的初始化。
    - Daemon process（守护进程，在后台用来处理网页，打印之类的活动 可用ps -x 查看）
    - 进程终止原因：正常/出错退出（自愿），严重错误/被其它进程终止（非资源），用kill发送信号或exit终止自身
- 进程层次结构---进程树
- 进程状态及转换
    1. 运行态（running） 2. 就绪态（ready） 3. 阻塞态（blocked）---------三种状态之间的转换（此处应有图）运行状态和就绪状态之间的转换是由调度器引起的
    - 其他状态：new: 分配进程标识符，创建管理进程相关的表项，但未执行，未加载到内存。退出/终止状态：进程不能再被执行，一些进程信息被暂时保存（如： accounting program that cumulates resource usage for 
billing the users.?），之后再删除。----五种状态之间的转换（此处应有图）。
    - 操作系统视图
       processes
    0 1 ... n-2 n-1
       scheduler
      最底层处理中断与调度，上层是串行程序
- 进程的实现
    - 进程控制块（PCB），==内容会动态改变==，是由OS维护的一块内存。是每个进程在OS中的登记表项。处于核心段，要通过内核态访问。或通过UNIX中的进程文件系统（/proc）直接访问进程映像（image），文件名未进程标识符，创建者可读写。
    - 进程描述信息：进程标识符，进程名，用户标识符，进程组关系（process group）
    - PCB的内容
        - 进程控制信息：当前状态，优先级，代码执行入口地址，程序的外存地址，运行统计信息（执行时间，页面调度），进程间同步和通信，阻塞原因。
        - 资源占用信息：虚拟地址空间的现状，打开文件列表。
        - CPU现场保护结构：寄存器值（通用，PC，状态PSW，地址包括栈指针）
    - PCB的组织方式
        - 链表，一个状态一个链表
        - 索引表，同个状态一个Index表，由index指向PCB
    - MINIX进程控制块  struct task_struct 进程表被分为几个部分，各模块维护自己的域
    - 进程切换过程实现，保存当前进程的PCB，再载入另一进程的PCB
    - 每类I/O设备都有一个靠近内存底部的位置叫中断向量。
    - 中断处理步骤：1. 硬件。。。（待填）
- 线程及实现
    - 线程：一个进程再一个地址空间的多个控制流，CPU调度单位，而进程是资源分配单位。线程只有一些必不可少的资源如==线程状态，寄存器上下文和栈==。有就绪，阻塞和执行三种状态。
    - 线程减小并发执行的时间和空间开销。创建、终止、切换的时间都比进程短。线程切换可不通过内核的通信。
    - 线程应用：web server
    - 线程实现方式：
        - 内核线程：由内核的内部需求进行创建和撤销。内核维护进程和线程的上下文，线程切换--内核，一个线程发起系统调用被阻塞--不影响其他线程运行。以线程分配时间片，多线程的进程更多CPU时间。
        - 用户线程：应用进程管理和调度用户线程，调度通常采用非抢占式和更简单的规则，不需要模式切换。一个线程发起系统调用而阻塞，则整个进程在等待。以进程分配时间片，多线程则每个线程很慢。---优点：可针对应用优化。
        - 混合方案，如Solaris--Multiple user threads on a kernel thread 一个内核线程上有多个用户线程。
    - 进程和线程比较
        - 地址空间和其他资源（如打开的文件）
        - 进程通过进程间通信IPC，线程可直接读写进程数据段（如全局变量）来进行通信。
        - 线程调度比进程调度快得多，不需要上下文切换，修改内存映射，高速缓存失效等。
        - 线程共享进程的地址空间，因此可能会导致竞争，因此对某一块有多个线程要访问的数据需要一些同步技术。
### 进程间通信
- 涉及问题：如何向另一个进程传递信息；多个进程涉及临界活动时不会彼此影响；有相互依存关系的进程保证正确的执行次序。关于线程，传递信息可以利用共享的地址空间，而另两方面的问题解决适用于线程。
- ==竞争条件==（race conditions）：两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序。
- 临界区：对共享内存进行访问的程序片段。
    - 避免竞争条件：两个进程不能同时处于临界区。不应对CPU的速度和数目作任何假设。临界区外的进程不得阻塞其他进程。不得使进程在临界区外无休止等待。
- 忙等待形式互斥
    - 关中断：进程进入临界区后关中断，在离开之前开中断。这样关中断的权力在用户进程，且关中断仅仅对执行本指令的CPU有效，而关中断是一种很有用的技术（比如CPU刚进中断时要保护现场，此时关中断（网上）），但对用户进程不是合适的通用机制
    - 锁变量---会发生竞争条件
    - 严格交替法：确保两个进程严格==轮流==进入临界区，容易导致临界区外的进程阻塞其他进程
    - Peterson解法 while(turn==process && interested[other]==TRUE);
    - ==TSL解法==（测试并上锁需要硬件支持），将一个存储器字读到一个寄存器中，读数和写数操作保证不可分割。TSL REGISTER,LOCK(汇编指令)，执行TSL指令的CPU将锁住内存总线以禁止其他CPU在本指令结束之前访问内存。
- 睡眠和唤醒
    - 优先级翻转问题----一个高优先级进程忙等待（阻塞转为就绪并运行时），低优先级进程处在临界区不能被调度。
    - 无法进入临界区时被阻塞，而不是忙等待--用sleep和wakeup
    - ==生产者-消费者问题==（有界缓冲区问题），生产者负责把消息放入缓冲区，消费者负责从缓冲区取出消息，缓冲区满时，让生产者睡眠，当消费者从缓冲区读数据发现数据为空时，消费者睡眠。知道生产者将其唤醒。------但存在竞争条件，需要一个变量count来查看缓冲区数据项，count=0时生产者读取count和wakeup消费者之后count++和消费者读取count睡眠之间存在先后--唤醒信号丢失----------弥补：增加唤醒等待位，但如果有更多的进程，此方法不适用。
- ==信号量==
    - 原语：由若干条指令构成的原子操作过程。系统调用并不都是原语。
    - down和up（操作不可分割，是一般化的sleep和wakeup），作为系统调用，操作系统在执行（检测信号量、修改信号量以及在需要时使进程休眠）时会关闭中断。如果使用多个CPU，每个信号量要由一个锁变量进行保护，通过TSL指令来保证同一时刻只有一个CPU在对信号量进行操作
    - 用信号量解决生产者-消费者问题
        - 使用三个信号量，full（满槽数）, empty（空槽数），mutex（二进制信号量 0 1用于控制临界区（信息放取缓冲区时）的进入）
        - 具体看代码
- 互斥（mutex，不需要信号量的计数）P(mutex)和V(mutex)加锁解锁，如果多个进程在互斥上阻塞，则随机选择一个进程并允许它获得锁。
- 管程（Moniter,高级的同步原语，实现互斥由编译器负责），是过程、变量和相关数据结构的集合构成一个特殊的模块或软件包，是一种特殊的数据类型。提高代码可读性，正确性易于保证。
    - ==任意时刻管程中只能有一个活跃进程==（互斥进入） 
    - 进程能在任何时候调用管程中的过程，但不能在管程外的过程直接访问管程内的数据结构
    - 将所有的临界区转换为管程中的过程即可。
    - 引入条件变量，使得如生产者发现缓冲区满时被阻塞---在管程内部实现等待机制。相关的两个操作（以条件变量full为例）：wait(full)和signal(full)（对比sleep和waitup，管程的过程是互斥的）（这两个操作是在条件变量上执行的。。。），条件变量不是计数器，不能累积，信号可能丢失。但实际不需要累积，通过检查变量来判断该操作是否需要，wait必须在signal之前,否则信号被丢弃。
    - Pascal和Java等支持管程（Java没有条件变量）
    - 每个条件变量表示一种等待原因---如full，表示缓冲区满，其实相当于一种信号量。
    - 其他具体看代码
- 消息传递
    - 进行进程间通信，使用两条原语send和receive
    - 是系统调用，而不像管程那样是语言组件
    - send(destination, &message, &status) receive(source, &message, &status)。
    - 为防止信息丢失，接收方收到信息后马上回送一条特殊的应答消息，若一段时间未收到应答，则重发。
    - 区分新信息和重发的老信息---每条信息里加入一个连续的序号。
    - 基于消息传递的生产者-消费者（代码）,引入一种新的数据结构称为信箱（对一定数量的消息进行缓冲），使用信箱时，send和receive调用中的地址参数使用信箱，而不是进程。向满信箱发送消息时会被挂起。消息是固定大小的。
    - MPI(消息传送接口)
    - 身份认证也是个问题
    - 聚合原则：send在receive之前发送，则发送进程被阻塞，直到receive发生。
### 经典IPC（inter-process communication）问题
- 哲学家进餐问题（多个进程互斥访问有限资源，如I/O）
    - 死锁：同时na
    - 饥饿：所有程序都在运行但不能取得进展。
    - 方案1：规定在拿到左叉后，查看右叉是否可用，如果不可用，放下左叉。哲学家在拿不到右叉时候，等待一段随机的时间。----很多应用中都适用，如局域网中计算机发送数据包可能碰撞。
    - 方案2：改进：使用一个二进制信号量，哲学家拿叉子之前，先对信号量mutex执行down操作，放回之后，再执行up操作。但实际有性能的局限：同一时刻只能有一个哲学家进餐，而五把叉子实际允许两个哲学家共同进餐。
    - 方案3（能获得最大并行度）使用一个state数组来跟踪哲学家是再吃饭，思考，还是正在试图拿叉子。LEFT,RIGHT表示左右邻居。
- 读者-写者问题
    - 读-写互斥
    - 写-写互斥
    - 方案1：第一个读者对db进行down操作，随后的读者只是增加计数器rc，最后一个读者对db进行up操作。但如果有多个读者一直进入，写者就会一直挂起。
    - 方案2：在写者后面的读者被挂在写者后面，但这种解法的并发性较低，性能较差。
### 进程调度
- 操作系统做出决定哪个进程运行的部分叫调度器，使用的算法是调度算法。很多进程调度的处理方式对线程也适用。
- 进程行为
    - 根据CPU计算时间和I/O时间的比例，进程可以分为①计算密集型②I/O密集型
    - 调度时机：进程瑞出；进程在I/O或信号量上阻塞；创建了一个新进程；I/O中断发生；时钟中断发生（抢占式调度）；（后三个不是必需）
    - 调度算法的分类：批处理，交互式（），实时
    - 共同目标：公平性，策略强制性，平衡性；
        - 批处理：最大化吞吐量，最小化周转时间，最大化CPU利用率
        - 交互式系统：最小化响应时间，均衡性
        - 实时系统：满足截止时间，可预测性
    - 性能指标
        - 面向用户：
            - 周转时间：作业从提交到完成所经历的时间
            - 响应时间（命令提交到得到结果）
            - 截止时间
            - 公平性：不因作业本身的特性而使指标过分恶化。如长作业等待很长时间。
        - 面向系统：
            - 吞吐量：单位时间内完成的作业数
            - CPU利用率：CPU做计算的时间与总时间的比值
            - 各种设备的均衡利用
- 批处理系统调度
    - 先到先服务（First Come First Serve）
    - 最短作业优先（只有在作业同时启动时候才是最优的）（SJF）
    - 最短剩余时间优先（SRT）
    - 最高相应比优先（响应比R= (等待时间 + 要求执行时间) / 要求执行时间, 是FCFS和SJF的折衷）
    - 三级调度
        - 准入调度器：作业允许进入或临时保存在输入队列中（典型的算法是找一些计算密集型和I/O密集型的进程混合一起进行）
        - 内存调度器：哪些在内存，哪些换出到磁盘，周期性评估磁盘上的每个进程，内存中保留的进程数目称为多道程序的道数。
        - CPU调度器：选取将要运行的进程
- 交互式系统调度
    - 时间片轮转（时间片的长度应合理20-50ms，cpu约花费1ms进行上下文切换）
    - 优先级调度
        - 静态优先级
            - 确定优先级的依据：进程类型（系统进程还是用户进程），对资源的需求（对CPU和内存需求较少的进程优先级高），用户要求（紧迫程度和付费多少）
        - 动态优先级
            - 就绪队列中等待时间延长则优先级提高
            - 进程每执行一个时间片就降低优先级。
    - 多类优先级调度
        - 进程按优先级分类，各类之间采用优先级调度，各类进程内部采用时间片轮转调度。
    - 多重队列  CTSS(分时系统)
        - CTSS进程切换速度太慢（内存只放得下一个进程，故要换出磁盘再从磁盘读入）
        - 优先级越低则时间片越长，如逐级加倍。
        - 新进程进入内存后，先放入最高优先级队列的末尾，按先到先服务算法调度；若一个进程在其时间片内未执行完，降低到次高优先级队列的末尾。再按先到先服务算法。
        - 仅当较高优先级队列未空，才调度较低优先级的进程，如果新进程优先级较高，会抢占，被抢占的进程放入原队列末尾。
    - 最短进程优先
    - 彩票调度算法
        - 为进程发放针对系统各种资源（如CPU时间）的彩票，调度程序随机选择一张彩票（相当于按比例分配资源）
        - 中奖机会与持有的彩票数成正比。
    - 公平分享调度
        - 如两个用户，需要保证各使用一半CPU资源
- 实时系统调度
    -  实时系统分为硬实时系统（必须满足时间限制）和软实时系统（偶尔可以超过时间限制）
    -  事件分为周期性（每隔一段固定的时间发生）和非周期性（再不可预测的时间发生）
    -  ==可调度==的实时系统：一个系统可能必须响应多个周期的事件流，有m个周期性事件，事件i的周期为Pi，每个事件i需要Ci秒的CPU时间处理，则只有满足每个Ci/Pi的和小于等于1（忽略了上下文切换的开销），这个系统才是可调度的。
    -  实时调度算法可以是静态或动态。
- 调度策略与机制
    - 将调度算法以某种形式参数化（调度机制），而参数可以由用户进程依据相应的策略设置（调度策略）
    - 例如：数据库管理系统由很多子进程，每个子进程可能处理不同的请求，或者实现不同的功能。
    - 若内核使用优先级调度算法，提供一条系统调用，一个进程可以使用它来设置或改变子进程的优先级。父进程不调度但它可以控制子进程如何被调度的细节。这里的机制位于内核，而策略则由用户进程设定。
- 线程调度
    - 线程调度的处理取决于线程的实现方式，即用户级线程，内核级线程还是两者都支持。
    - 用户级线程：
        - 进程内部的线程调度器决定哪个线程运行
        - 用户级线程的阻塞会引起整个进程的阻塞
        - 在用户级线程方式下，可以为应用制定特定的调度器
    - 内核级线程：内核挑选线程运行，而不管它是哪个进程。但由于进程切换开销大，内核应考虑这个因素。 
### MINIX3进程概述
- MINIX3系统结构
    - 微内核结构
    - 四层结构：用户进程，服务器进程，设备驱动程序内核进程。（图）
    - 内核层
        - 最底层，运行在内核模式，在底层进行进程调度，负责进程调度，处理所有进程间通信，支持对I/O端口和中断的访问
        - 时钟任务模块，产生时钟信号
        - 系统任务模块，读写I/O端口、跨地址复制数据
        - C语言+汇编语言实现
    - 设备驱动层
        - 调用内核中的系统任务模块，读写I/O端口的数据
        - 不同类型设备，需哟啊相应的设备驱动程序
        - 也可以调用其它内核调用
    - 服务器层
        - 进程管理器（PM）
            - 创建、终止进程：fork, exec, wait
            - 信号相关的系统调用：alarm, kill
            - 管理内存：brk
        - 文件系统服务器（FS）
            - 执行文件系统的调用：read, mount, chdir
        - 再生服务器（RS）
            - 启动或重启相关的设备驱动程序
            - 负责转换进程使其从普通用户进程变为系统进程而开始运行的MINIX3组件
        - 服务器不能直接进行I/O操作，可以通过驱动程序（还是在用户空间）来请求I/O，服务器也可以通过系统任务与内核通信。(系统任务指在内核态执行的)
    - 用户进程层
        - 包括所有的用户进程：
            - shell、编辑器、编译器等工具程序
            - 用户运行的程序
            - 守护进程：周期性运行的后台进程
            - init进程（先启动init进程再启动其他系统进程）
            - 可能还有守护进程（Deamon）是周期性运行或总是等待某个事件（如网络上一个包的到达）的后台进程
    - 资源管理主要由第二层的驱动程序来做，系统调用的解释由第三层的进程管理器和文件系统来做。
    - ==系统进程：设备驱动层和服务器层的进程（不是系统任务）==
    - 一般情况下的进程优先级：内核进程>设备驱动层进程>服务器层进程>用户进程层进程
- MINIX3进程管理
    - 启动顺序：bootstrap（引导程序，在软盘、光盘或者磁盘上）->boot(boot image，引导映像->boot程序在软盘或硬盘找一个包含多个部分的文件，并将各部分装到内存的适当位置，其中最重要的部分是内核（包括时钟任务和系统任务）、进程管理器，文件系统)->kernel->系统任务、时钟任务->系统进程->init进程->其它用户进程
>     - init进程
>         - 引导映像最后加载的一个进程
>         - PID为1，但不是系统中运行的第一个进程
>         - 执行/etc/rc脚本，结合再生服务器进程，启动其他的驱动程序和服务器
>         - 执行/etc/rc脚本，启动守护进程
>         - 读取其他配置文件，进行系统检查，启动终端设备，启动用户登陆界面，启动shell

- MINIX3进程间通信
    - IPC原语
        - 内核将消息从发送者复制到接收者。
        - 系统进程，时钟任务，系统任务只允许与特定的进程通信。
        - 当一个进程发送消息，而目标进程尚未开始接收消息时，发送进程将阻塞。
    - notify原语
        - 用于一个进程向另一个进程发送通知消息
        - notify调用不会阻塞
        - 通知中可以时最简单的内容：发送者身份和时间戳
        - 对于==系统进程==，可以采用bitmap(位图)for pending notifications实现
            - 每个系统进程由这样一个位图（bitmap，用bit表示的，点阵图），其中的每一位对应于一个系统进程，用于记录其他系统进程发给它的通知。
            - 当系统进程调用receive时，通过检查自己的位图，可以知道其它系统进程是否发通知给它
- MINIX3进程调度
    - 采用多级排队系统，定义16个队列
    - 系统任务和时钟任务处于最高优先级
    - IDLE进程在系统没有其它进程时运行，具有最低优先级。
    - 一个进程可以根据需要在不同优先级的队列中移动
    - 只有高优先级队列中没有就绪进程，才运行低优先级的进程队列
    - 不同优先级中的进程的时间片长度不一：驱动程序进程和服务器进程通常需要运行至阻塞，为此它们分配较大的时间片（和之前的多重队列时间不同）
    - 使用一个改进的轮转调度算法
        - 进程转为非就绪时，它的时间片没用完，则表明发生I/O阻塞，则该进程再次转为就绪，将其==放在队首==，分配的时间片为上次时间片中的剩余时间。
        - 用完时间片的进程放在队列队尾
### MINIX3进程实现
- 源码组织与编译
    - 源码组织
        - src/include 头文件目录
        - src/kernel 调度，消息，时钟和系统任务，实现MINIX3的第一层功能，编译为同一个二进制文件，但以三个进程独立运行（内核，时钟任务，系统任务）
        - src/drivers 驱动程序（磁盘、打印）
        - src/servers 服务器进程（进程管理器、文件系统管理器）
        - src/lib 库例程（open, read...）
        - src/boot 引导和安装系统的代码
        - src/tools Makefile和脚本（用于编译系统）
        - src/drivers 实现设备驱动层（第二层）
        - src/server/pm 实现进程管理器（第三层）
        - src/server/fs 实现文件系统管理器
    - 编译
        - make, Makefile
        - src/tools
        - 分别进入每个源码目录，为每个部分生成相应的二进制可执行文件
    - 引导映像
        - installboot负责生成引导映像文件
        - 在src/tools/中可以找到新编译的引导映像文件
        - 需要放至/boot/image或/boot中
    - 内存分布（图）
- 头文件
    - 公共头文件
        - src/include
        - sec/include/sys
        - 由POSIX标准规定
    - MINIX头文件
        - src/include/minix
            - config.h--硬件相关的配置
        - src/include/ibm
            - 在IBM类型机器
    - 头文件说明
        - #include <filename> 到默认头文件目录去查找
        - "filename" 首先在源文件所在的目录查找，没找到再到默认目录查找
- 进程数据结构
    - 进程表
        - 进程表被分为三部分：内核、进程管理器、文件系统服务器
        - 内核进程表：src/kernel/proc.h，进程寄存器，栈指针，进程状态，内存映像，栈限制，进程ID，accounting，时钟，消息
    - 进程的特权级
        - 32位intel 提供四个特权级
        - MINIX用到三个特权级
            - 0 内核和中断处理器
            - 1 内核任务
            - 3 服务器和用户进程
- 系统引导
    - Boot与bootblock
        - boot是MINIX的次级装入程序，它不仅可以装入操作系统，而且作为一个监控程序，它允许用户改变、设置和保存不同的参数
        - boot从它所在分区的第二个扇区寻找一套可用的参数（MINIX保留每个硬盘设备的前1K字节作为一个引导块（bootblock）,其中只有一个扇区（512字节）被ROM引导程序或主引导扇区装入）
- 系统初始化
    - MINIX3内核被成功加载到内存后，控制权会转移到kernel/mpx.s文件，根据机器字长（整数运算位数）为16位或32位来分别加载mpx88.s或者mpx386.s
- 中断处理
    - 中断信号出现在中断控制器芯片右侧的IRQn信号线上，通过CPU INT管脚的连接线通知CPU发生了中断
    - CPU发出INTA（中断应答）信号
    - 中断控制器芯片将数据放在系统数据总线上并通知处理器应执行哪个服务例程
    - CPU执行被选中的描述符所指向的代码（软件中断）
- 进程间通信
    - MINIX中的进程使用消息进行通信。
    - 当一个进程执行SEND时，核心的最底层检查目标进程是否在等待从发送者发来的消息。
        - 如果是，将该消息从发送者的缓冲区拷贝到接收者的缓冲区，同时这两个进程都被标记为就绪态
        - 如果目标进程未等待消息，发送者被标记为阻塞，并被挂入一个等待将消息发送到接收进程的进程队列中
    - 实现：sys_call（proc.c）
        - 检查并保证该消息指定的源进程和目标进程合法性及消息指针合法性
        - 验证目标进程正在运行，没有启动终止过程
        - 调用mini_send, mini_receive, mini_notify
        - 防止发生死锁
        - 试图向进程0发送消息的进程被排队，形成一个链表，链表头由进程0的p_caller_q域记录
- 进程调度
    - 实现（proc.c）
    - enqueue 将进程加入到某优先级队列中
        - 调用sched
        - 根据需要修改rdy_head[q], rdy_tail[q]
    - dequeue
        - 将进程状态转为非就绪态时候调用
        - 将阻塞的进程移出队列
    - sched
        - 确定一个新就绪的进程放在哪个队列上，放首还是放尾
    - pick_proc
        - 设置下一个运行进程，即next_ptr的值
### MINIX3系统任务
- 系统任务概述
    - 系统任务作为==内核中的一个进程==被独立调度
    - 系统任务接收所有来自驱动程序和服务器层进程的相关服务请求----读写I/O端口，跨地址空间复制数据等
    - 系统调用
        - 再整体式内核的操作系统中，系统调用是对内核提供服务的调用
        - MINIX3中，用户进程发出的系统调用被转换为发往服务器进程的消息，服务器进程处理部分工作后，将给系统任务进程发消息，然后由系统任务完成剩下的工作
        - 系统任务接受对于内核服务的请求，称为内核调用（如sys_fork()）
    - 系统任务接收的消息类型（28条，每种对应一个内核调用）
        - 进程管理类（sys_fork, sys_exit...）
        - 信号类(sys_kill, sys_getksig...)
        - 内存类(sys_newmap,...)
        - 时间类
        - 系统控制
- 系统任务实现
    - system.h, system.c
        - 系统任务的主框架
        - 通过函数指针数组call_vec，将消息类型（数字）作为数组索引，确定相应的函数以响应服务请求(map(SYS_FORK, do_fork))
        - 系统任务的顶层是sys_task过程，其再初始化函数指针数组之后，进入一个循环以等待消息。在对消息做有效性验证之后，根据消息类型调用相应的函数
    - kernel/system目录，包含了实现每个响应函数的源文件
- 系统库的实现
    - sysytem.c中每一个名字为do_xy形式的函数的源码在kernel/system/do_xyz.c文件中
    - 这些函数可以分为两大类
        - 代表用户态进程访问内核数据结构
            - do_setalarm.c
        - 一些系统调用，大部分工作在用户空间进程处理，需要在内核空间下做些操作
            - do_exec.c
- 初始化：建立消息与函数库的关联
    - map(SYS_FORK, do_fork)...
- 例：exec->do_exec
    - 进程管理器完成exec系统调用的大部分工作
    - 为设置进程表内核数据结构中的栈指针，由do_exec来处理
        - 栈指针被设置在了进程表的内核部分
        - 如果该进程使用了附加段，将调用函数phy_neneset以擦除在这个内存区域中可能留有先前应用中的残留数据
    - 调用exec的进程，发送消息给进程管理器后阻塞
        - 不同于其它的系统调用，响应结果将接触阻塞，exec没有相应
        - do_exec为进程解除阻塞，并使成为就绪
- 实例：系统任务的角色
    - read系统调用
        - 最坏情况：用户执行read调用后，文件系统检查它的缓冲区以确定是否由所需哟啊的数据，发现没有后，它会向磁盘驱动程序发送消息，以请求（系统任务）将该数据块加载到缓冲区区，然后文件系统发送一条消息给系统任务以通知将该数据块复制到用户进程
        - 最好情况：用户执行read调用后，文件系统检查缓冲区发现有所需数据，于是请求系统任务将数据复制给用户
### MINIX3时钟任务
    - 时钟（也称为定时器）
    - 维护日常时间，并且防止某一进程独占CPU
    - 时钟既不是像磁盘一样的块设备，也不是像终端一样的字符设备
    - 时钟任务类似于设备驱动程序有硬件设备的中断驱动
- 时钟硬件
    - 可编程时钟
        - 由三个元件组成：晶振，计数器和一个保持寄存器
        - 石英晶体-->用于产生精确的周期信号
        - 在任何计算机系统中，都至少可以发现一个这样的电路向计算机的各种电路提供同步信号。把这个信号送入计数器并使其递减计数至零，当计数至零时，产生一个中断。
    - 可编程模式
        - 单触发模式
            - 当一个时钟启动时，它把保持寄存器的值拷贝到计数器中，然后每从晶振来一个脉冲，对计数器值减一，当计数器为0时产生一个中断
        - 方波模式
            - 每次计数至0并引起中断以后，保持寄存器自动拷贝到计数器，整个过程不断重复执行，这些周期性的中断称为时钟滴答
- 计时程序
    - 时钟任务的作用：
        - 维护日常时间
        - 防止进程的运行时间超出其允许的时间
        - 审计CPU使用时间
        - 处理用户进程提出的alarm系统调用
        - 对系统某些部分提供看门狗时钟
        - 执行测试统计、监视获取统计数据
    - 为实现第一个功能，记录1970年1月1日以来的节拍数用32位计数器不够
        - 1. 改为64位计数器，但这样1秒会多很多运算
        - 2. 以秒为单位维护日常事件
        - 3. 按节拍数，但是相对系统启动时间
    - 看门狗时钟：时钟驱动程序处理看门狗的机制和对待用户信号的机制是一样的，唯一不同是定时器时间到时，时钟驱动程序将调用一个调用者提供的过程（一段代码）而不是产生一个信号。
- 时钟驱动程序概述
    - 包含在kernel/clock.c中
    - 主循环，等待消息然后指定相应的子程序执行
    - 中断处理程序，维护基本的日常事件俺，更新记录系统启动以来的时钟节拍数的变量，与下次定时器到时的时间比较等。若检测到进程完成了时间片，发送返回主循环的消息
- 时钟驱动程序实现
